[ch [title Parser (Reader)]

    The preceding chapter showed [i what we can do] with the pXML parser. Now we'll dive deeper and see [i how it works], and how you can use and customize the parser for your own specific needs.

    [note
        The parser's source code is available on [link url=[!get Github_parser_repo] text=Github], and it's API is documented [link url=[!get Java_API_doc_url] text=here].
    ]

    [ch [title Event-Based]

        The parser is [i event-based]. It reads a pXML document and generates a stream of events. The parser itself doesn't do anything with the parsed data. Each type of event (e.g. [c onNodeStart, onNodeEnd], etc.) is handled by a callback function. All callback functions are part of an events handler object. Before parsing, the client code must pass an events handler object to the parser. The events handler is an interface containing one callback function for each type of event. It is defined as [link url=[!get Github_parser_repo_main]/reader/parser/eventHandler/IParserEventsHandler.java text=follows]:

        [insert_code file = [!get local_src_dir]/reader/parser/eventHandler/IParserEventsHandler.java lang=java]

        Type parameter [c N] defines the type of the nodes generated by this events handler. Type parameter [c R] defines the type of the final result created when parsing is terminated.

        [!set eventHandler_root_url = [!get Github_parser_repo_main]/reader/parser/eventHandler]

        The following implementations of [c IParserEventsHandler] are included in the core library:
        [list
            
            [el
                [link url=[!get eventHandler_root_url]/CreateDOM_ParserEventHandler.java text = CreateDOM_ParserEventHandler]

                This handler creates a standard Java [c org.w3c.dom.Document] object. It's the handler used in the previous chapter when we validated or transformed a pXML document.
            ]

            [el
                [link url=[!get eventHandler_root_url]/CreateAST_ParserEventHandler.java text = CreateAST_ParserEventHandler]

                Besides creating a [c Document] object, we can create a pXML specific AST with this handler. The end result is a [link url=[!get Java_API_doc_src_url]/data/node/PXMLNode.html text=PXMLNode].
            ]

            [el
                [link url=[!get eventHandler_root_url]/WriteXML_ParserEventHandler.java text = WriteXML_ParserEventHandler]

                If we just need to convert pXML to XML then the most efficient way is to use this handler.
                Instead of loading the whole pXML document into an internal tree structure, each item (name, attribute, text, etc.) is immediately written to a Java [c Writer], as soon as it is parsed.
                Hence, very large documents can be converted quickly and without eating up internal memory.
            ]

            [el
                [link url=[!get eventHandler_root_url]/Logger_ParserEventHandler.java text = Logger_ParserEventHandler]

                This is a utility handler that writes logging data to a Java [c Writer] (default is standard OS out device).
                Can be used for debugging purposes.
            ]

            [el
                [link url=[!get eventHandler_root_url]/DoNothing_ParserEventHandler.java text = DoNothing_ParserEventHandler]

                As the name suggest, this handler doesn't do anything. It's useful in these cases:
                [list
                    [el We just want to know if an error is reported by the parser (e.g. malformed pXML document)]
                    [el We don't want to handle all events. In that case we can create an events handler that inherits from this one, and overwrites the functions we care about.]
                ]
            ]

            [el
                [link url=[!get eventHandler_root_url]/Timer_ParserEventHandler.java text = Timer_ParserEventHandler]

                This events handler inherits from  [c DoNothing_ParserEventHandler], and overwrites functions [c onStart] and [c onEnd] to measure the total parsing time.
            ]
        ]
    ]

    [ch [title Customized Parsing]

        If none of the above handlers suits your needs, you can create your own customized events handler by creating a class that implements [c IParserEventsHandler], and pass it to a [link url=[!get Github_parser_repo_main]/reader/parser/EventStreamParser.java text=parser] that implements [link url=[!get Github_parser_repo_main]/reader/parser/AEventStreamParser.java text=AEventStreamParser].
        To get started you can have a look at the implementations mentioned in the previous chapter.

        A parser uses an [link url=[!get Github_parser_repo_main]/reader/tokenizer/ITokenizer.java text=ITokenizer] to read pXML tokens (name, text, comment, etc.). For maximum customization, you could provide your own tokenizer and/or parser and use it with pXML's core library.
    ]

    [ch [title Parser Properties And Features]

        [list
            [el The parser is in a [i proof of concept] state, not ready yet to be used in production.]
            [el Written in Java.]
            [el Free and open-sourced under MIT license.]
            [el No dependencies.]
            [el Just one +-55 kB .jar file]
            [el Fast (no regexes used)]
            [el Event-based. Therefore low memory footprint, even when reading large documents.]
            [el Customized event handlers can be provided. Increases versatility]
            [el Able to load pXML into a standard Java [c org.w3c.dom.Document] object. Therefore all XML technology based on [c Document] can be used (validation, querying, transformation etc.).]
            [el Uses standard Java [c Reader] / [c Writer] for flexible input/output configurations.]
        ]
    ]

    [ch [title XML Features Not Yet Supported]

        The following features are not yet supported in the current implementation:

        [list
            [el CDATA sections]
            [el processing instructions]
            [el DTD (replaced by XML Schema; will not be supported in pXML)]
        ]
    ]
]
